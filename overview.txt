RegLang - A simple language that complies into a regular expression

The first assignment in the file represents the final
regular expression.

Expressions cannot be cyclic, meaning that no expression can include
itself

Basic steps:
    1. Tokenize file
    2. use CFG to build a graph of the regular expression
    3. Analyze graphs for cycles. If any exist, throw an error
    4. Begin substituting expressions for their regex counterparts.
        - This should be done by walking the CFG parse tree
    5. Print regex

Objects needed:
    
    token_list - After a file is tokenized, it is turned into a list
        of tokens. This list contains some metadata, such as the
        number of tokens in the list

    dependency_tree - The CFG should build this tree structure. One of
        its purposes is to analyze the regex to determine if there are
        any cycles. If so, an error will be thrown. This graph will
        also be used to build the resulting regex with a simple in order
        graph traversal

Syntax:
    
    keywords:
        followed
        by
        repeated
        or
        more
        times
        from
        to
        optional
        character
        between
        and
        not
        the
        set
        newline
        tab
        any
  
    CFG:
        file:       [assignment]+

        assignment: [identifier]: [expression] ; [newline]
        
        expression: [expr_start]
                    [expr_start] followed by [expression]
                    [expr_start] repeated [integer] or more times
                    [expr_start] repeated from [integer] to [integer] times
                    [expr_start] repeated [integer] times
                    optional [expression]
                    [expr_start] or [expresion]
                    any character between [char] and [char]
                    any character not between [char] and [char]
                    any character from the set [charset]
                    any character not from the set [charset]

        expr_start: [string]
                    [char]
                    [ [identifier] ]
                    ( [expression] )

        charset:    [ [char] ( , [char] )* ]

        char:       ' . '
                    newline
                    tab
                    0x[0-9A-Fa-f][0-9A-Fa-f]
                    any character

        string:     " .* "

        identifier: [a-zA-Z_] [a-zA-Z0-9_]+ (but not one of the keywords in the above list)

        integer:    0 | [1-9] [0-9]*

Example regexes:
    
    The following RegLang expression:
        
        real:       '0' or [number];
        number:     ( optional [sign] ) followed by [integer] followed by optional [decimal];
        sign:       '-' or '+';
        integer:    [nonzero] followed by ( [digit] repeated 0 or more times );
        nonzero:    a character between '1' and '9';
        digit:      a character between '0' and '9';
        decimal:    '.' followed by ( [digit] repeated 1 or more times );

    would compile into the following regex:
        
        0|-?([1-9][0-9]*)(.[0-9]*)?
    
